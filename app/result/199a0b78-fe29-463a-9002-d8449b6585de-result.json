{"name": "testFaile", "status": "failed", "statusDetails": {"message": "AssertionError", "trace": "self = <CallInfo when='call' exception: >\nfunc = <function call_runtest_hook.<locals>.<lambda> at 0x00000174C2F3AB70>\nwhen = 'call'\n\n    def __init__(self, func, when):\n        #: context of invocation: one of \"setup\", \"call\",\n        #: \"teardown\", \"memocollect\"\n        self.when = when\n        self.start = time()\n        try:\n>           self.result = func()\n\n..\\..\\naenv\\lib\\site-packages\\_pytest\\runner.py:192: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>   return CallInfo(lambda: ihook(item=item, **kwds), when=when)\n\n..\\..\\naenv\\lib\\site-packages\\_pytest\\runner.py:178: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <_HookCaller 'pytest_runtest_call'>, args = ()\nkwargs = {'item': <JsonItem 'testFaile'>}, notincall = set()\n\n    def __call__(self, *args, **kwargs):\n        if args:\n            raise TypeError(\"hook calling supports only keyword arguments\")\n        assert not self.is_historic()\n        if self.argnames:\n            notincall = set(self.argnames) - set(['__multicall__']) - set(\n                kwargs.keys())\n            if notincall:\n                warnings.warn(\n                    \"Argument(s) {} which are declared in the hookspec \"\n                    \"can not be found in this hook call\"\n                    .format(tuple(notincall)),\n                    stacklevel=2,\n                )\n>       return self._hookexec(self, self._nonwrappers + self._wrappers, kwargs)\n\n..\\..\\naenv\\lib\\site-packages\\pluggy\\__init__.py:617: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <_pytest.config.PytestPluginManager object at 0x00000174C2259B00>\nhook = <_HookCaller 'pytest_runtest_call'>\nmethods = [<pluggy.HookImpl object at 0x00000174C2968CC0>, <pluggy.HookImpl object at 0x00000174C32074E0>, <pluggy.HookImpl object at 0x00000174C3D58080>, <pluggy.HookImpl object at 0x00000174C3D584E0>]\nkwargs = {'item': <JsonItem 'testFaile'>}\n\n    def _hookexec(self, hook, methods, kwargs):\n        # called from all hookcaller instances.\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\n>       return self._inner_hookexec(hook, methods, kwargs)\n\n..\\..\\naenv\\lib\\site-packages\\pluggy\\__init__.py:222: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nhook = <_HookCaller 'pytest_runtest_call'>\nmethods = [<pluggy.HookImpl object at 0x00000174C2968CC0>, <pluggy.HookImpl object at 0x00000174C32074E0>, <pluggy.HookImpl object at 0x00000174C3D58080>, <pluggy.HookImpl object at 0x00000174C3D584E0>]\nkwargs = {'item': <JsonItem 'testFaile'>}\n\n    self._inner_hookexec = lambda hook, methods, kwargs: \\\n        hook.multicall(\n            methods, kwargs,\n>           firstresult=hook.spec_opts.get('firstresult'),\n        )\n\n..\\..\\naenv\\lib\\site-packages\\pluggy\\__init__.py:216: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nhook_impls = [<pluggy.HookImpl object at 0x00000174C2968CC0>, <pluggy.HookImpl object at 0x00000174C32074E0>, <pluggy.HookImpl object at 0x00000174C3D58080>, <pluggy.HookImpl object at 0x00000174C3D584E0>]\ncaller_kwargs = {'item': <JsonItem 'testFaile'>}, firstresult = False\n\n    def _multicall(hook_impls, caller_kwargs, firstresult=False):\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from _HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results = []\n        excinfo = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    \"hook call must provide argument %r\" % (argname,))\n    \n                    if hook_impl.hookwrapper:\n                        try:\n                            gen = hook_impl.function(*args)\n                            next(gen)   # first yield\n                            teardowns.append(gen)\n                        except StopIteration:\n                            _raise_wrapfail(gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException:\n                excinfo = sys.exc_info()\n        finally:\n            if firstresult:  # first result hooks return a single value\n                outcome = _Result(results[0] if results else None, excinfo)\n            else:\n                outcome = _Result(results, excinfo)\n    \n            # run all wrapper post-yield blocks\n            for gen in reversed(teardowns):\n                try:\n                    gen.send(outcome)\n                    _raise_wrapfail(gen, \"has second yield\")\n                except StopIteration:\n                    pass\n    \n>           return outcome.get_result()\n\n..\\..\\naenv\\lib\\site-packages\\pluggy\\callers.py:201: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pluggy.callers._Result object at 0x00000174C3D70C50>\n\n    def get_result(self):\n        \"\"\"Get the result(s) for this hook call.\n    \n            If the hook was marked as a ``firstresult`` only a single value\n            will be returned otherwise a list of results.\n            \"\"\"\n        __tracebackhide__ = True\n        if self._excinfo is None:\n            return self._result\n        else:\n            ex = self._excinfo\n            if _py3:\n>               raise ex[1].with_traceback(ex[2])\n\n..\\..\\naenv\\lib\\site-packages\\pluggy\\callers.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nhook_impls = [<pluggy.HookImpl object at 0x00000174C2968CC0>, <pluggy.HookImpl object at 0x00000174C32074E0>, <pluggy.HookImpl object at 0x00000174C3D58080>, <pluggy.HookImpl object at 0x00000174C3D584E0>]\ncaller_kwargs = {'item': <JsonItem 'testFaile'>}, firstresult = False\n\n    def _multicall(hook_impls, caller_kwargs, firstresult=False):\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from _HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results = []\n        excinfo = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    \"hook call must provide argument %r\" % (argname,))\n    \n                    if hook_impl.hookwrapper:\n                        try:\n                            gen = hook_impl.function(*args)\n                            next(gen)   # first yield\n                            teardowns.append(gen)\n                        except StopIteration:\n                            _raise_wrapfail(gen, \"did not yield\")\n                    else:\n>                       res = hook_impl.function(*args)\n\n..\\..\\naenv\\lib\\site-packages\\pluggy\\callers.py:180: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nitem = <JsonItem 'testFaile'>\n\n    def pytest_runtest_call(item):\n        _update_current_test_var(item, 'call')\n        try:\n>           item.runtest()\n\n..\\..\\naenv\\lib\\site-packages\\_pytest\\runner.py:109: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <JsonItem 'testFaile'>\n\n    def runtest(self):\n        # for name, value in sorted(self.spec.items()):\n        #     # some custom test execution (dumb example follows)\n        #     if name != value:\n        #\n        req, validates = core.analyzejson(self.spec)\n>       res = core.httpcass(req,validates)\n\nconftest.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nreq = {'headers': {'Content-Type': 'application/json'}, 'json': {'aaa': 'bbb'}, 'method': 'GET', 'timeout': 10, ...}\nvalidates = [{'Equal': ['r.json()', 'req[\"json\"]']}, {'Equal': ['r.status_code', '201']}]\n\n    def httpcass(req,validates):\n        '''\n        requests接口方法,\n        req为requests所需参数的字典,\n        validates为校验所用的字典\n        '''\n        try:\n            r = requests.request(**req)\n        except requests.exceptions.Timeout as timeout:\n            raise timeout\n        for validate in validates:\n            validate = validate.items()\n            # print(validate)\n            for key, values in validate:\n>               assert eval(values[0] + asserts[key] + values[1])\nE               AssertionError\n\ncore.py:29: AssertionError"}, "start": 1524176311080, "stop": 1524176311095, "uuid": "8c357a9c-b6d5-45b7-b50b-3e59005da154", "historyId": "d05db6e10641cf4ee66a0635b397ec0d", "fullName": "test_json#testFaile", "labels": [{"name": "host", "value": "LangJin"}, {"name": "thread", "value": "7364-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "test_json"}]}